<!-- This file is autogenerated. DO NOT EDIT. -->

# Daisy: Subscription Contracts Audit

<img height="100px" Hspace="30" Vspace="10" align="right" src="static-content/diligence.png"/>

* [1 Summary](#1-summary)
  * [1.1 Audit Dashboard](#11-audit-dashboard)
  * [1.2 Audit Goals](#12-audit-goals)
  * [1.3 System Overview](#13-system-overview)
  * [1.4 Key Observations/Recommendations](#14-key-observationsrecommendations)
* [2 Issue Overview](#2-issue-overview)
* [3 Issue Details](#3-issue-details)
  * [3.1 Contract state is insufficient to determine whether a subscription is still valid](#31-contract-state-is-insufficient-to-determine-whether-a-subscription-is-still-valid)
  * [3.2 `maxExecutions` can be bypassed via `SubscriptionManager.execute` reentrancy](#32-maxexecutions-can-be-bypassed-via-subscriptionmanagerexecute-reentrancy)
  * [3.3 Consider adding expiration dates to signatures](#33-consider-adding-expiration-dates-to-signatures)
  * [3.4 Consider disallowing future `start` timestamps](#34-consider-disallowing-future-start-timestamps)
  * [3.5 `SubscriptionManager` is not robust to additions to the `PeriodUnit` enum](#35-subscriptionmanager-is-not-robust-to-additions-to-the-periodunit-enum)
  * [3.6 Update inline documentation](#36-update-inline-documentation)
  * [3.7 `maxExecutions` special case value of `0` should be replaced with `2**256-1`](#37-maxexecutions-special-case-value-of-0-should-be-replaced-with-2256-1)
  * [3.8 Front-running denial of service against subscribers](#38-front-running-denial-of-service-against-subscribers)
  * [3.9 Relayers can incur unlimited transaction costs due to malicious users](#39-relayers-can-incur-unlimited-transaction-costs-due-to-malicious-users)
* [4 Threat Model](#4-threat-model)
  * [4.1 Overview](#41-overview)
  * [4.2 Threat Analysis](#42-threat-analysis)
* [5 Tool-Based Analysis](#5-tool-based-analysis)
  * [5.1 Mythril](#51-mythril)
  * [5.2 Ethlint](#52-ethlint)
  * [5.3 Surya](#53-surya)
* [6 Test Coverage Measurement](#6-test-coverage-measurement)
* [Appendix 1  - File Hashes](#appendix-1----file-hashes)
* [Appendix 2  - Severity](#appendix-2----severity)
  * [A.2.2 - Minor](#a22---minor)
  * [A.2.3 - Medium](#a23---medium)
  * [A.2.4 - Major](#a24---major)
  * [A.2.5 - Critical](#a25---critical)
* [Appendix 3  - Disclosure](#appendix-3----disclosure)


## 1 Summary

ConsenSys Diligence conducted a security audit on Daisy Subscription contract by Token Foundry (ConsenSys).

Daisy is a smart contract for subscriptions and supports multiple different use cases, such as plan/tier based subscriptions. Daisy smart contract can be used as the core on-chain module for any subscription-model application.

### 1.1 Audit Dashboard
________________

#### Audit Details

* **Project Name:** Daisy: Subscription Contracts
* **Client Name:** Daisy
* **Client Contact:** Vicente Dragicevic (vicente.dragicevic@consensys.net)
* **Lead Auditor:** Shayan Eskandari
* **Co-auditors:** Steve Marx
* **Date:** April 8th, 2019

#### Number of issues by severity

| | **Minor** | **Medium** | **Major** | **Critical** |
|:-------------:|:-------------:|:-------------:|:-------------:|:-------------:|
| **Open** | **0** | **0** | **0** | **0** |
| **Closed** | **7** | **2** | **0** | **0** |

________________

### 1.2 Audit Goals

The focus of the audit was to verify that the smart contract system is secure, resilient and working according to its specifications. The audit activities can be grouped in the following three categories:  

**Security:** Identifying security related issues within each contract and within the system of contracts.

**Sound Architecture:** Evaluation of the architecture of this system through the lens of established smart contract best practices and general software best practices.

**Code Correctness and Quality:** A full review of the contract source code. The primary areas of focus include:

* Correctness
* Readability
* Sections of code with high complexity
* Improving scalability
* Quantity and quality of test coverage

### 1.3 System Overview

#### Documentation

The following documentation was available to the audit team:

* The [NatSpec](https://tokenfoundry.github.io/subscription-contracts/docs/SubscriptionManager.html) with short description about the subscription contract, libraries and the use cases.
* The [README](https://github.com/tokenfoundry/subscription-contracts/blob/master/README.md) explaining the concept and main functionality of the Subscriptions and Plans.

#### Scope

The audit focus was on the smart contract files, and test suites found in [subscription-contracts](https://github.com/tokenfoundry/subscription-contracts/):

|  Directory | Commit hash | Commit date |
|----------|-------------|-------------|
| [contracts](https://github.com/tokenfoundry/subscription-contracts/tree/master/contracts)  | 30770831a533990cb1729faa30897d8cf4d47dd7 | 26th March 2019 |

#### Design

### 1.4 Key Observations/Recommendations  

#### Positive Observations

* The code is well written and documented.
* The library architecture is efficient and the code does not use any complex inheritance model.
* The code contains many helpful inline comments.
* A good security practice is not to allow main critical variables to be changed after deployment. This is done correctly with some variables such as acceptedToken and the plan details.

#### Recommendations

* The subscription contract is used as the core module that will be used by a backend or an application. Proper documentation of the workflow of such an application is required to ensure the secure implementation of the subscription model.
* Logic can be simplified in a number of places. Specific suggestions can be found in the Issue Details section.
* Some test scenarios are not tested, such as removing a plan that has been already removed.


## 2 Issue Overview

The following table contains all the issues discovered during the audit. The issues are ordered based on their severity. More detailed description on the levels of severity can be found in the Severity Definitions Appendix. The table also contains the status of any discovered issue.

| Chapter      | Issue Title             | Issue Status | Severity    |
|:------------:| ----------------------- |:------------:|:-----------:|
| 3.1  | [Contract state is insufficient to determine whether a subscription is still valid](#31-contract-state-is-insufficient-to-determine-whether-a-subscription-is-still-valid) | **Closed**  | **Medium** |
| 3.2  | [`maxExecutions` can be bypassed via `SubscriptionManager.execute` reentrancy](#32-maxexecutions-can-be-bypassed-via-subscriptionmanagerexecute-reentrancy) | **Closed**  | **Medium** |
| 3.3  | [Consider adding expiration dates to signatures](#33-consider-adding-expiration-dates-to-signatures) | **Closed**  | **Minor** |
| 3.4  | [Consider disallowing future `start` timestamps](#34-consider-disallowing-future-start-timestamps) | **Closed**  | **Minor** |
| 3.5  | [`SubscriptionManager` is not robust to additions to the `PeriodUnit` enum](#35-subscriptionmanager-is-not-robust-to-additions-to-the-periodunit-enum) | **Closed**  | **Minor** |
| 3.6  | [Update inline documentation](#36-update-inline-documentation) | **Closed**  | **Minor** |
| 3.7  | [`maxExecutions` special case value of `0` should be replaced with `2**256-1`](#37-maxexecutions-special-case-value-of-0-should-be-replaced-with-2256-1) | **Closed**  | **Minor** |
| 3.8  | [Front-running denial of service against subscribers](#38-front-running-denial-of-service-against-subscribers) | **Closed**  | **Minor** |
| 3.9  | [Relayers can incur unlimited transaction costs due to malicious users](#39-relayers-can-incur-unlimited-transaction-costs-due-to-malicious-users) | **Closed**  | **Minor** |

## 3 Issue Details

### 3.1 Contract state is insufficient to determine whether a subscription is still valid

| Severity     | Status    | Remediation Comment |
|:------------:|:---------:| ------------------- |
| **Medium** | **Closed** | Issue has been fixed in [tokenfoundry/subscription-contracts#32](https://github.com/tokenfoundry/subscription-contracts/pull/32) with the recommended remediation |

#### Description

`SubscriptionManager.execute()` always advances `_nextPayment`, even if the payment did not go through. If a subscription does not have enough funds to pay for the executed period, `_nextPayment` is incremented before `_cancel()` is called. The contract state after such a failed payment is indistinguishable from a _successful_ payment followed by cancelation.

#### Example

1. A user signs up for an annual subscription with `maxExecutions = 1`.
2. This subscription is immediately executed.
3. The user **has or has not** sufficiently funded their subscription.

Regardless of whether payment was collected, at the end of `execute()`, the subscription is in the canceled state with the next payment due in 1 year.

Without carefully monitoring the event log, a publisher can't determine whether they should provide service to the user for the next year. Furthermore, because canceling a subscription deletes it from the smart contract, the publisher can no longer see the details of the subscription, including when it started. Note that this is true during the last payment period of every subscription: e.g. the 12th month of a year-long monthly subscription.

#### Remediation

The event log does contain enough information for a publisher to reconstruct the proper state of a subscription, but it would be better if the contract state allowed a publisher to easily determine whether a given subscriber should still be receiving service.

To that end, we recommend the following contract semantics:

1. A subscription is considered _valid_ if it's been executed at least once and its next payment is due in the future. Note that this is unaffected by whether or not a subscription has been _canceled_.
2. `executions` is always the number of times a subscription _has been paid for_.
3. The next payment is always due at time `executions + periodUnits * period`. (Note that this means the `_nextPayment` mapping can be removed entirely and instead calculated as needed.)
4. Canceling a subscription just marks it as canceled, which means it will subject to deletion the next time payment is due.
5. Subscription data is only deleted once a subscription is no longer valid. (Payment is due but could not be collected due to insufficient funds, already reaching max executions, or cancelation.)

With those semantics, a publisher can determine whether to provide service by examining the subscription's fields. If the subscription has been executed at least once and the next payment is due in the future (perhaps including some grace period), then service should be provided.
### 3.2 `maxExecutions` can be bypassed via `SubscriptionManager.execute` reentrancy

| Severity     | Status    | Remediation Comment |
|:------------:|:---------:| ------------------- |
| **Medium** | **Closed** | Issue has been fixed in [tokenfoundry/subscription-contracts#32](https://github.com/tokenfoundry/subscription-contracts/pull/32) by, among other things, moving the `transferFrom` call to the end of the function |

#### Description

`execute()` is subject to reentrancy if:

1. The ERC20 token being transferred makes an external call. ERC223 tokens are a popular example of tokens making external calls to the recipient.
2. Two payment periods have elapsed, such that after the first payment is executed, a second payment is still due.

Note that if condition 1 holds, condition 2 can be forced by the publisher simply by `revert`ing any payments until two periods have elapsed.

This reentrancy can allow a malicious publisher to exceed  the `maxExecutions` limit imposed on a subscription. This could be used to continue charging a subscriber beyond the agreed-upon time limit.

#### Example

`sub.executions` is incremented first:

**contracts/SubscriptionManager.sol:L344**
```solidity
sub.executions += 1;
```

Then the `_nextPayment` is updated:

**contracts/SubscriptionManager.sol:L347-L355**
```solidity
uint256 nextPeriods = sub.executions.mul(sub.periods);

if (sub.periodUnit == PeriodUnit.Day) {
    _nextPayment[subscriptionHash] = sub.start.addDays(nextPeriods);
} else if (sub.periodUnit == PeriodUnit.Month) {
    _nextPayment[subscriptionHash] = sub.start.addMonths(nextPeriods);
} else if (sub.periodUnit == PeriodUnit.Year) {
    _nextPayment[subscriptionHash] = sub.start.addYears(nextPeriods);
}
```

Note that it's possible for the `_nextPayment` timestamp to still be in the past if, for example, it's been more than two months since a monthly payment has been collected.

Then the ERC20 token transfer occurs:

**contracts/SubscriptionManager.sol:L367-L371**
```solidity
token.safeTransferFrom(
    sub.subscriber,
    wallet,
    sub.amount
);
```

Here, the recipient of the transfer can call back into `execute` as long as another payment is due.

And finally `maxExecutions` is checked:

**contracts/SubscriptionManager.sol:L376-L379**
```solidity
bool expired = (
    sub.maxExecutions != 0 &&
    sub.executions == sub.maxExecutions
);
```

Because exact equality (`==`) is used to check `executions` against `maxExecutions`, if it has been incremented twice, the subscription's `maxExecutions` can be exceeded without triggering cancelation. Subsequent executions need not use any sort of reentrancy to continue exceeding the `maxExecutions` limit.

#### Remediation

The simplest solution is to use the checks-effects-interactions pattern, which would move the external call to perform the token transfer to the very end of the function. Other solutions to avoid reentrancy are possible, but they're all harder to reason about.

A code comment mentions ordering things the way it's done now to preserve ordering of emitted events, but this is likely not important enough to put correctness at risk. Also, the event could still be emitted where it is even if the transfer is moved to the bottom of the function.

(As an aside, it might also be better to use a greater-than-or-equal-to (`>=`) comparison to mitigate the effects of a bug like this.)
### 3.3 Consider adding expiration dates to signatures

| Severity     | Status    | Remediation Comment |
|:------------:|:---------:| ------------------- |
| **Minor** | **Closed** | Issue has been fixed by introducing signature expirations in [tokenfoundry/subscription-contracts#32](https://github.com/tokenfoundry/subscription-contracts/pull/32) |

#### Description

As a general best practice, it's a good idea for signatures to have expiration dates. This avoids future surprises when an old signature is used much later.

#### Examples

Here's an example of a transaction relayer using an old signature:

1. Alice decides to sign up for a year's subscription to a service called "MythX". She creates a signature indicating as much and hands it off to MythX so they can relay it for her.
2. MythX doesn't relay the transaction and instead stores it.
3. Alice tries again. This time MythX relays the transaction and everything looks good.
4. MythX relays the original transaction, signing Alice up for two overlapping subscriptions, and essentially double bills her. Or, MythX waits a year and sends the original transaction then, extending Alice's subscription unbeknownst to her.

Depending on Alice's token balance and amount `approve`d, this may be costly to Alice. The only mitigation available to her is to carefully watch her subscriptions at all times, and even then, she can't prevent at least one extra payment from happening.

Here's an example of a private plan being hard to control:

1. A service "MythX" decides to open up a beta but only wants 100 concurrent users to be able to sign up for it. They authorize 100 users by signing 100 `privAuth` signatures.
2. Only 50 of those users actually sign up.
3. MythX decides to authorize 50 more users, who all sign up.
4. The remaining 50 from the first batch of signatures decide at a later date to sign up. Now there are 150 subscribers to the plan.

#### Remediation

We suggest attaching an expiration date to all signatures. If the expectation is that signatures are typically used immediately, this expiration date could be in the very near future—perhaps between 1 hour and 24 hours after the signature has been constructed.
### 3.4 Consider disallowing future `start` timestamps

| Severity     | Status    | Remediation Comment |
|:------------:|:---------:| ------------------- |
| **Minor** | **Closed** | Issue has been fixed by removing `start` and just using `createdAt` in [tokenfoundry/subscription-contracts#32](https://github.com/tokenfoundry/subscription-contracts/pull/32) |

#### Description

At present, subscriptions can be created with future `start` timestamps. There seems to be no benefit to allowing this, and it makes using the contract more complicated in several ways. If future timestamps were disallowed, the `start` parameter could be removed altogether.

#### Examples

As noted in another issue, relayers probably shouldn't relay subscription creation transactions that use a future `start` timestamp. It opens them up to attack.

As noted in a different issue, the fact that it's possible for a subscription to exist but never to have been executed makes it harder to determine whether a subscription is valid or not. For example, `SubscriptionManager.isActive` has a special case for `executions == 0`:

**contracts/SubscriptionManager.sol:L168-L179**
```solidity
function isActive(bytes32 subscriptionHash)
    external
    view
    returns(bool)
{
    return (
        // Payment in the future
        now < _nextPayment[subscriptionHash] &&
        // Has been executed
        _subscriptions[subscriptionHash].executions != 0
    );
}
```

`SubscriptionManager._create` has similar extra logic for handling `start` dates:

**contracts/SubscriptionManager.sol:L575-L578**
```solidity
// The subscription can't start in the past
bool shouldStartNow = start <= now;

uint256 startsAt = shouldStartNow ? now : start;
```

**contracts/SubscriptionManager.sol:L603-L605**
```solidity
if (shouldStartNow) {
    execute(subscriptionHash);
}
```

#### Remedation

We recommend simply disallowing future `start` dates and removing the parameter from `SubscriptionManager._create` and `PlanSubscriptionManager.create`. The `start` timestamp is then implicitly always just `now`.
### 3.5 `SubscriptionManager` is not robust to additions to the `PeriodUnit` enum

| Severity     | Status    | Remediation Comment |
|:------------:|:---------:| ------------------- |
| **Minor** | **Closed** | Issue has been closed by reverting on invalid `periodUnit` in [tokenfoundry/subscription-contracts#32](https://github.com/tokenfoundry/subscription-contracts/pull/32) |

#### Description

In multiple places, `SubscriptionManager` uses a chain of conditionals to handle the different `PeriodUnit` enum values, but it doesn't handle unknown values. This is an issue for future contract maintenance.

#### Examples

`SubscriptionManager._getPeriodUnitHash` has the following logic:

**contracts/SubscriptionManager.sol:L635-L641**
```solidity
if (periodUnit == PeriodUnit.Day) {
    return keccak256("Day");
} else if (periodUnit == PeriodUnit.Month) {
    return keccak256("Month");
}

return keccak256("Year");
```.

If a new `PeriodUnit.Minute` is added in the future, this code will incorrectly return the hash of "Year". This would mean that a signature for yearly subscription terms could be used to create a per-minute subscription.

Note that even without a new enum value being added to the code, Solidity's built-in checking around enum values is not performed on values passed to a function, so someone can simply pass an invalid number like 123 to trigger this case. (In the particular code that uses this function, the enum value is later written to storage, where a check _does_ occur.)

A much worse case is `SubscriptionManager.execute()`:

**contracts/SubscriptionManager.sol:L346-L355**
```solidity
// nextPaymentTimestamp always increases as sub.periods can't be 0.
uint256 nextPeriods = sub.executions.mul(sub.periods);

if (sub.periodUnit == PeriodUnit.Day) {
    _nextPayment[subscriptionHash] = sub.start.addDays(nextPeriods);
} else if (sub.periodUnit == PeriodUnit.Month) {
    _nextPayment[subscriptionHash] = sub.start.addMonths(nextPeriods);
} else if (sub.periodUnit == PeriodUnit.Year) {
    _nextPayment[subscriptionHash] = sub.start.addYears(nextPeriods);
}
```

Here, if someone added a `PeriodUnit.Minute` but failed to update this function, then the `_nextPayment` value would not be increased at all. This would leave the subscription due for collection again, and, especially for a subscription with no max executions set, the subscriber's balance could be instantly drained.

#### Remediation

Revert transactions when an unknown enum value is encountered. For example:

```solidity
// nextPaymentTimestamp always increases as sub.periods can't be 0.
uint256 nextPeriods = sub.executions.mul(sub.periods);

if (sub.periodUnit == PeriodUnit.Day) {
    _nextPayment[subscriptionHash] = sub.start.addDays(nextPeriods);
} else if (sub.periodUnit == PeriodUnit.Month) {
    _nextPayment[subscriptionHash] = sub.start.addMonths(nextPeriods);
} else if (sub.periodUnit == PeriodUnit.Year) {
    _nextPayment[subscriptionHash] = sub.start.addYears(nextPeriods);
} else {
    revert("Unknown period unit!");
}
```
### 3.6 Update inline documentation

| Severity     | Status    | Remediation Comment |
|:------------:|:---------:| ------------------- |
| **Minor** | **Closed** | Issue has been closed in [tokenfoundry/subscription-contracts#32](https://github.com/tokenfoundry/subscription-contracts/pull/32) |

#### Description
There are a few inline documentations that are related to the older versions and are misleading.

#### Examples
**contracts/SubscriptionManager.sol:L103**
```solidity
// Replay guard, see DelegatedSubscriptionManager.sol
```

#### Remediation
Update the inline documentations according to the changes.

### 3.7 `maxExecutions` special case value of `0` should be replaced with `2**256-1`

| Severity     | Status    | Remediation Comment |
|:------------:|:---------:| ------------------- |
| **Minor** | **Closed** | The client team has decided to leave this as-is for now. There are no known vulnerabilities relating to this at present, and fixes for this require changes elsewhere in the system (back end and front end). |

#### Description

In a number of places in the code, the value `0` has to be treated as a special case meaning "unlimited". At least one bug has already been discovered (in an earlier version of the code) due to a mistake around this.

#### Examples

**contracts/usecases/PlanSubscriptionManager.sol:L267-L268**
```solidity
require(
    plan.maxExecutions == 0 || maxExecutions <= plan.maxExecutions,
```

**contracts/usecases/PlanSubscriptionManager.sol:L308**
```solidity
maxExecutions == 0 ? plan.maxExecutions : maxExecutions,
```

**contracts/SubscriptionManager.sol:L376-L379**
```solidity
bool expired = (
    sub.maxExecutions != 0 &&
    sub.executions == sub.maxExecutions
);
```

#### Remediation

Inside the contract, use the value `2**256-1` (maximum allowed `uint256`) instead. This effectively _is_ infinite, as the logic calls for. No special cases are then required; simple mathematical comparisons will always do the right thing.

Note that external UI can still display a string like "unlimited". Even signatures can still use the value `0` for better UI in, e.g., MetaMask. The value just needs to be converted immediately to `2**256-1` inside the contract. (This means having special-case logic in fewer places, and the failure mode is that a subscription can't be executed, rather than that it can be executed indefinitely.)
### 3.8 Front-running denial of service against subscribers

| Severity     | Status    | Remediation Comment |
|:------------:|:---------:| ------------------- |
| **Minor** | **Closed** | Issue has been fixed in [tokenfoundry/subscription-contracts#32](https://github.com/tokenfoundry/subscription-contracts/pull/32) by adding the `subscriber` to the `subscriptionHash` |

#### Description

Subscription hashes do not include the subscriber, so front-running attacks are possible where an attacker is able to prevent a legitimate user from create a subscription. Note that the impact of this issue is quite low. An attacker has to pay transaction fees just to censor another user's subscription. The other user can simply retry with a new nonce.

#### Example

1. Alice tries to create a subscription with certain terms: plan ID, start time, max executions, and a nonce.
2. Eve races to call `PlanSubscriptionManager.create` with the same arguments by sending a transaction with a high gas price.
3. If Eve wins that race, then Alice's subscription cannot be created (due to the signature replay guard).
4. Alice has to pick a new nonce and try again, but Eve can repeat the process.

#### Remediation

A simple solution would be to include the subscriber in the subscription hash.

Note that this is somewhat mitigated already for _private plans_ because the hash signed by the `authSig` already includes the subscriber, but an attacker may be able to quickly obtain an `authSig` for their own account and still succeed in their front-running attack.
### 3.9 Relayers can incur unlimited transaction costs due to malicious users

| Severity     | Status    | Remediation Comment |
|:------------:|:---------:| ------------------- |
| **Minor** | **Closed** | Issue has been fixed in [tokenfoundry/subscription-contracts#32](https://github.com/tokenfoundry/subscription-contracts/pull/32) by disallowing `start` dates in the future and thus immediately executing all subscriptions. (Relayers should still check balances before relaying.) |

#### Description

In `PlanSubscriptionManager`, each subscription is created by a meta transaction. The subscriber signs the terms of a subscription, indicating their desire to sign up under those terms. A relaying entity—in this case probably a central backend—then calls `create` with the given arguments and the signature. This relayer must pay a transaction fee.

An attacker can exploit this by repeatedly asking the relayer to create new subscriptions. If the attacker sets a far-future `start` date or simply doesn't `allow` any tokens to be transferred, there is no cost to the attacker aside from the negligible computation required to sign the subscription terms.

#### Remediation

The relayer can protect themselves by only relaying subscription creations that meet the following criteria:

1. The subscriber has a sufficient token balance and has `allow`ed sufficient tokens to be transferred by the `PlanSubscriptionManager` contract.
2. The `start` date is in the past.

If those conditions are met, then the new subscription will be instantly executed and at least one payment will be collected. There's a narrow window of opportunity for the attacker to reduce their `allowance` or token balance via front-running, but this changes the economics drastically from the attacker mounting an attack for free to the attacker having to pay transaction fees for each attack.

## 4 Threat Model

The creation of a threat model is beneficial when building smart contract systems as it helps to understand the potential security threats, assess risk, and identify appropriate mitigation strategies. This is especially useful during the design and development of a contract system as it allows to create a more resilient design which is more difficult to change post-development.

A threat model was created during the audit process in order to analyze the attack surface of the contract system and to focus review and testing efforts on key areas that a malicious actor would likely also attack. It consists of two parts a high level design diagram that help to understand the attack surface and a list of threats that exist for the contract system.

### 4.1 Overview

The following assets are managed by contracts and likely targets for an attacker:

- Tokens used as subscription payment
- Subscriptions
  - Private plans

The following actors have access to the system to perform an attack:

- Publisher (Authorizer)
- Subscriber

Any user not subscribed to a subscription-based plan should not be able to access the resources offered by that plan. Also, as there are delegated signatures involved, these signatures should not be able to be replayed.

There are some attack surfaces in regards to the tokens used in the DApp that are worthy to keep in mind. However, based on the logic of the subscription model, they are not important in the proposed use cases. As the publisher specifies the `acceptedToken` in the contract, and the subscriber has access to the token address prior to subscribing to the plan, we assume the token is trusted and does not have malicious code. The subscription contract also uses `safeERC20`, which adds more protection against possible malicious token implementations.

### 4.2 Threat Analysis

The following table contains a list of identified threats, along with their mitigations:

|  Threat | Attack Strategy | Mitigation |
|-------------|-------------|-------------|
| user may subscribe to a plan with zero or lower fees | overflow on the amount / manipulate the plan price | SafeMath mitigates some potential math errors |
| user may remove the token funds before executing the plan | front-running on `transfer()` | proper checks for the token approved balance before executing the subscription period |
| user may try to access resources without subscribing | circumvent subscription checks or off-chain implementation | proper checks in the off-chain implementation |
| user may try to reuse authorizer signature in delegated calls | replay attack | include subscriber address and nonce in every delegated call |
| user A may grief user B | front-running / DoS | include subscriber address (B) in the the creation of subscription |
| user may use an inactive/removed subscription | flaw in the active subscription conditions | having one go-to function to check if the subscription is active |
| publisher may bill the subscriber more than initial agreement | executing more than one subscription per period | proper checks in the contract prevents such attack vector |

## 5 Tool-Based Analysis

Several tools were used to perform automated analysis of the reviewed contracts. These issues were reviewed by the audit team, and relevant issues are listed in the Issue Details section.

### 5.1 Mythril

<img height="120px" align="right" src="static-content/mythril.png"/>

Mythril is a security analysis tool for Ethereum smart contracts. It uses concolic analysis to detect various types of issues. The tool was used for automated vulnerability discovery for all audited contracts and libraries. More details on Mythril's current vulnerability coverage can be found [here](https://github.com/ConsenSys/mythril/wiki).

The raw output of the Mythril vulnerability scan can be found [here](./tool-output/mythril/mythril_report.md).

### 5.2 Ethlint

<img height="120px" align="right" src="static-content/ethlint.png"/>

[Ethlint](https://www.ethlint.com/) is an open source project for linting Solidity code. Only security-related issues were reviewed by the audit team.

The raw output of the Ethlint vulnerability scan can be found [here](./tool-output/ethlint/ethlint_report.md).

### 5.3 Surya

Surya is an utility tool for smart contract systems. It provides a number of visual outputs and information about structure of smart contracts. It also supports querying the function call graph in multiple ways to aid in the manual inspection and control flow analysis of contracts.

A complete list of functions with their visibility and modifiers can be found [here](./tool-output/surya/surya_report.md).

## 6 Test Coverage Measurement

Tests are implemented using truffle tests (`mocha`, running on `ganache`, compiling with `solc: 0.5.4+commit.9549d8ff`). 119 tests are included in the test suite and they all pass.

The [Solidity-Coverage](https://github.com/sc-forks/solidity-coverage) tool was used to measure the portion of the code base exercised by the test suite, and identify areas with little or no coverage. Specific sections of the code where necessary test coverage is missing are included in chapter 3 - Issues.


|File                          |  % Stmts | % Branch |  % Funcs |  % Lines |Uncovered Lines |
|------------------------------|----------|----------|----------|----------|----------------|
| contracts/                   |    98.37 |    85.14 |      100 |    98.41 |                |
|  SubscriptionManager.sol     |    98.37 |    85.14 |      100 |    98.41 |        214,732 |
| contracts/usecases/          |      100 |    78.26 |      100 |      100 |                |
|  PlanSubscriptionManager.sol |      100 |    78.26 |      100 |      100 |                |
|------------------------------|----------|----------|----------|----------|----------------|
|All files                     |    98.85 |     82.5 |      100 |    98.88 |                |
|------------------------------|----------|----------|----------|----------|----------------|

It's important to note that "100% test coverage" is not a silver bullet. Our review also included an inspection of the test suite, to ensure that testing included important edge cases. As mentioned in the recommendation section, we found some scenarios that are not covered by the test suite. 

The state of test coverage at the time of our review can be viewed by opening the `index.html` file from the [coverage report](coverage-reports) directory in a browser.

## Appendix 1  - File Hashes

The SHA1 hashes of the source code files in scope of the audit are listed in the table below.

## Appendix 2  - Severity

### A.2.2 - Minor

Minor issues are generally subjective in nature, or potentially deal with topics like "best practices" or "readability".  Minor issues in general will not indicate an actual problem or bug in code.

The maintainers should use their own judgment as to whether addressing these issues improves the codebase.

### A.2.3 - Medium

Medium issues are generally objective in nature but do not represent actual bugs or security problems.

These issues should be addressed unless there is a clear reason not to.

### A.2.4 - Major

Major issues will be things like bugs or security vulnerabilities.  These issues may not be directly exploitable, or may require a certain condition to arise in order to be exploited.

Left unaddressed these issues are highly likely to cause problems with the operation of the contract or lead to a situation which allows the system to be exploited in some way.

### A.2.5 - Critical

Critical issues are directly exploitable bugs or security vulnerabilities.

Left unaddressed these issues are highly likely or guaranteed to cause major problems or potentially a full failure in the operations of the contract.

## Appendix 3  - Disclosure

ConsenSys Diligence (“CD”) typically receives compensation from one or more clients (the “Clients”) for performing the analysis contained in these reports (the “Reports”). The Reports may be distributed through other means, including via ConsenSys publications and other distributions.

The Reports are not an endorsement or indictment of any particular project or team, and the Reports do not guarantee the security of any particular project. This Report does not consider, and should not be interpreted as considering or having any bearing on, the potential economics of a token, token sale or any other product, service or other asset. Cryptographic tokens are emergent technologies and carry with them high levels of technical risk and uncertainty. No Report provides any warranty or representation to any Third-Party in any respect, including regarding the bugfree nature of code, the business model or proprietors of any such business model, and the legal compliance of any such business. No third party should rely on the Reports in any way, including for the purpose of making any decisions to buy or sell any token, product, service or other asset. Specifically, for the avoidance of doubt, this Report does not constitute investment advice, is not intended to be relied upon as investment advice, is not an endorsement of this project or team, and it is not a guarantee as to the absolute security of the project. CD owes no duty to any Third-Party by virtue of publishing these Reports.

PURPOSE OF REPORTS The Reports and the analysis described therein are created solely for Clients and published with their consent. The scope of our review is limited to a review of Solidity code and only the Solidity code we note as being within the scope of our review within this report. The Solidity language itself remains under development and is subject to unknown risks and flaws. The review does not extend to the compiler layer, or any other areas beyond Solidity that could present security risks. Cryptographic tokens are emergent technologies and carry with them high levels of technical risk and uncertainty.

CD makes the Reports available to parties other than the Clients (i.e., “third parties”) -- on its GitHub account (https://github.com/ConsenSys). CD hopes that by making these analyses publicly available, it can help the blockchain ecosystem develop technical best practices in this rapidly evolving area of innovation.

LINKS TO OTHER WEB SITES FROM THIS WEB SITE You may, through hypertext or other computer links, gain access to web sites operated by persons other than ConsenSys and CD. Such hyperlinks are provided for your reference and convenience only, and are the exclusive responsibility of such web sites' owners. You agree that ConsenSys and CD are not responsible for the content or operation of such Web sites, and that ConsenSys and CD shall have no liability to you or any other person or entity for the use of third party Web sites. Except as described below, a hyperlink from this web Site to another web site does not imply or mean that ConsenSys and CD endorses the content on that Web site or the operator or operations of that site. You are solely responsible for determining the extent to which you may use any content at any other web sites to which you link from the Reports. ConsenSys and CD assumes no responsibility for the use of third party software on the Web Site and shall have no liability whatsoever to any person or entity for the accuracy or completeness of any outcome generated by such software.

TIMELINESS OF CONTENT The content contained in the Reports is current as of the date appearing on the Report and is subject to change without notice. Unless indicated otherwise, by ConsenSys and CD.
